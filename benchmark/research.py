# -*- coding: utf-8 -*-
"""banch_marks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fzafB3-8z6Yk2khf4QQiT3iw0VV6K8Lo
"""

import re
import json
from Levenshtein import distance as levenshtein_distance
import spacy
from spacy.matcher import Matcher
from sklearn.metrics import precision_score, recall_score, f1_score
import time
import pandas as pd
import matplotlib.pyplot as plt

# Инициализация NLP модели
nlp = spacy.load("ru_core_news_sm")

# Эталонные данные
GROUND_TRUTH = [
    {"parameter": "гемоглобин", "value": 130.0, "unit": "г/л", "reference_range": [120, 145]},
    {"parameter": "тромбоциты", "value": 258.0, "unit": "10^9/л", "reference_range": [160, 400]},
    {"parameter": "лейкоциты", "value": 4.7, "unit": "10^9/л", "reference_range": [4.0, 9.0]},
    {"parameter": "эритроциты", "value": 4.7, "unit": "10^12/л", "reference_range": [3.5, 5.4]}
]

# Тестовые данные с ошибками
TEST_TEXT1 = """
Показатель — _|Результат| Норма _ |Ед. nam. — Коммент.
Гемоглобин (HGB) — | 130 _ | 120-145 | _г/л — а Г
Тромбоциты (PLT) | 258 | 160-400. 10^9/л oer
Лейкоциты (WBC) | 4Z | 4.0-90 | 10^9/л na
Эритроциты (RBC) | 47 | 35- 5,4 _| 10^12/л й
"""
TEST_TEXT = """
Показатель — _|Результат| Норма|Ед. nam. — Коммент.
Гемоглобин (HGB) — | 130 - | 120-145 | _г/л — а Г
Лейкоциты (WBC) | 4Z | 4.0-90 | 10^9/л na
Тромбоциты (PLT) | 258 | 160-400. 10^9/л oer
Эритроциты (RBC) | 47 | 35- 5,4 _| 10^12/л й
"""

# 1. Метод регулярных выражений
def extract_with_regex(text):
    results = []
    patterns = [
        (r"(гемоглобин|hgb)[^|]*\|[^|]*?(\d+)[^|]*\|[^|]*?(\d+)\s*[-–]\s*(\d+)[^|]*\|[^|]*?(г/л)", "гемоглобин", "г/л"),
        (r"(тромбоциты|plt)[^|]*\|[^|]*?(\d+)[^|]*\|[^|]*?(\d+)\s*[-–]\s*(\d+)[^|]*\|[^|]*?(10\^9/л)", "тромбоциты", "10^9/л"),
        (r"(лейкоциты|wbc)[^|]*\|[^|]*?(\d+)[^|]*\|[^|]*?(\d+\.?\d*)\s*[-–]\s*(\d+\.?\d*)[^|]*\|[^|]*?(10\^9/л)", "лейкоциты", "10^9/л"),
        (r"(эритроциты|rbc)[^|]*\|[^|]*?(\d+)[^|]*\|[^|]*?(\d+\.?\d*)\s*[-–]\s*(\d+\.?\d*)[^|]*\|[^|]*?(10\^12/л)", "эритроциты", "10^12/л")
    ]

    for pattern, param_name, unit in patterns:
        matches = re.finditer(pattern, text, re.IGNORECASE)
        for match in matches:
            try:
                value = float(match.group(2))
                ref_range = [float(match.group(3)), float(match.group(4))]
                results.append({
                    "parameter": param_name,
                    "value": value,
                    "unit": unit,
                    "reference_range": ref_range
                })
            except:
                continue

    return results

# 2. Метод на правилах
def extract_with_rules(text):
    results = []
    doc = nlp(text.lower())

    param_units = {
        "гемоглобин": "г/л",
        "тромбоциты": "10^9/л",
        "лейкоциты": "10^9/л",
        "эритроциты": "10^12/л"
    }

    for param, unit in param_units.items():
        if param in text.lower():
            # Ищем значение после параметра
            value_match = re.search(rf"{param}.*?\|.*?(\d+\.?\d*)", text.lower())
            # Ищем диапазон после значения
            range_match = re.search(rf"{param}.*?\|.*?\|.*?(\d+\.?\d*)\s*[-–]\s*(\d+\.?\d*)", text.lower())

            if value_match:
                try:
                    value = float(value_match.group(1).replace(',', '.'))
                    ref_range = None
                    if range_match:
                        ref_range = [
                            float(range_match.group(1).replace(',', '.')),
                            float(range_match.group(2).replace(',', '.'))
                        ]

                    results.append({
                        "parameter": param,
                        "value": value,
                        "unit": unit,
                        "reference_range": ref_range if ref_range else [0, 0]
                    })
                except:
                    continue
    return results

# 3. Метод схожести
def extract_with_similarity(text):
    known_params = {
        "гемоглобин": {"unit": "г/л", "range": [120, 145]},
        "тромбоциты": {"unit": "10^9/л", "range": [160, 400]},
        "лейкоциты": {"unit": "10^9/л", "range": [4.0, 9.0]},
        "эритроциты": {"unit": "10^12/л", "range": [3.5, 5.4]}
    }

    lines = [line.strip() for line in text.split('\n') if line.strip()]
    results = []

    for line in lines:
        line_lower = line.lower()
        best_match = None
        min_distance = float('inf')

        for param in known_params:
            current_distance = levenshtein_distance(param, line_lower[:len(param)+5])
            if current_distance < min_distance:
                min_distance = current_distance
                best_match = param

        if best_match and min_distance <= 5:
            value_match = re.search(r'(\d+\.?\d*)', line.replace(',', '.'))
            if value_match:
                try:
                    value = float(value_match.group(1))
                    results.append({
                        "parameter": best_match,
                        "value": value,
                        "unit": known_params[best_match]["unit"],
                        "reference_range": known_params[best_match]["range"]
                    })
                except:
                    continue
    return results

class MedicalReportParser:
    def __init__(self):
        self.nlp = spacy.load("ru_core_news_sm")
        self.unit_mapping = {
            'г/л': 'г/л',
            '10^9/л': '10^9/л',
            '10^12/л': '10^12/л'
        }
        self.parameter_mapping = {
            'гемоглобин': ['hgb', 'гемоглобин', 'hemoglobin'],
            'тромбоциты': ['plt', 'тромбоциты', 'platelets'],
            'лейкоциты': ['wbc', 'лейкоциты', 'leucocytes'],
            'эритроциты': ['rbc', 'эритроциты', 'erythrocytes']
        }
        self.setup_matcher()

    def setup_matcher(self):
        self.matcher = Matcher(self.nlp.vocab)
        patterns = [
            [{"LOWER": {"IN": ["гемоглобин", "hgb"]}}],
            [{"LOWER": {"IN": ["тромбоциты", "plt"]}}],
            [{"LOWER": {"IN": ["лейкоциты", "wbc"]}}],
            [{"LOWER": {"IN": ["эритроциты", "rbc"]}}]
        ]
        self.matcher.add("MED_PARAMS", patterns)

    def clean_text(self, text):
        if not text:
            return ""
        text = re.sub(r'[^а-яА-Яa-zA-Z0-9./^\-|]', ' ', str(text))
        text = re.sub(r'\s+', ' ', text).strip()
        return text

    def parse_value(self, value_str):
        if not value_str:
            return None
        cleaned = re.sub(r'[^0-9.,]', '', str(value_str).replace(',', '.'))
        try:
            return float(cleaned) if cleaned else None
        except:
            return None

    def parse_reference_range(self, ref_str):
        if not ref_str:
            return None
        ref_str = re.sub(r'[^0-9.,\- ]', '', str(ref_str))
        parts = re.split(r'[\-–]', ref_str, maxsplit=1)
        if len(parts) == 2:
            low = self.parse_value(parts[0].strip())
            high = self.parse_value(parts[1].strip())
            return [low, high] if low is not None and high is not None else None
        return None

    def extract_with_semantic(self, text):
        if not text:
            return []

        lines = [line.strip() for line in str(text).split('\n') if line.strip()]
        results = []

        for line in lines:
            try:
                doc = self.nlp(self.clean_text(line))
                matches = self.matcher(doc)

                if not matches:
                    continue

                match_id, start, end = matches[0]
                param_name = doc[start:end].text.lower() if doc[start:end].text else None
                if not param_name:
                    continue

                standardized_param = self.get_standard_param(param_name)
                if not standardized_param:
                    continue

                parts = [p.strip() for p in re.split(r'[\|]', line) if p.strip()]
                if len(parts) < 3:
                    continue

                raw_value = parts[1].split('_')[0].strip() if '_' in parts[1] else parts[1]
                value = self.parse_value(raw_value)

                ref_range = self.parse_reference_range(parts[2])

                unit = None
                for part in parts[2:]:
                    if not part:
                        continue
                    for u in self.unit_mapping:
                        if u in part.lower():
                            unit = u
                            break
                    if unit:
                        break

                if value is not None:
                    result = {
                        "parameter": standardized_param,
                        "value": value,
                        "unit": unit if unit else "unknown",
                        "reference_range": ref_range if ref_range else None
                    }
                    results.append(result)
            except Exception as e:
                print(f"Error processing line '{line}': {str(e)}")
                continue

        return results

    def get_standard_param(self, param):
        if not param:
            return None
        param = str(param).lower()
        for standard, variants in self.parameter_mapping.items():
            if param in variants:
                return standard
        return param
parser = MedicalReportParser()

# 4. Семантический метод
def extract_with_semantic(text):
    results = parser.extract_with_semantic(text)
    return results

def evaluate_method(method_func):
    start_time = time.time()
    try:
        results = method_func(TEST_TEXT)
    except Exception as e:
        print(f"Error in {method_func.__name__}: {str(e)}")
        return {'precision': 0, 'recall': 0, 'f1': 0, 'time': 0}

    exec_time = time.time() - start_time

    # Подготовка эталонных данных для сравнения
    gt_params = {item['parameter'] for item in GROUND_TRUTH}
    found_params = set()

    y_true = []
    y_pred = []

    for gt_item in GROUND_TRUTH:
        param = gt_item['parameter']
        gt_value = gt_item['value']
        gt_unit = gt_item['unit']
        gt_range = gt_item['reference_range']

        # Ищем соответствующий результат
        found = False
        for res in results:
            if res.get('parameter') == param:
                found = True
                found_params.add(param)

                # Проверяем соответствие с допуском 0.1
                value_ok = abs(res.get('value', 0) - gt_value) < 0.1
                unit_ok = res.get('unit', '').lower() == gt_unit.lower()

                # Более мягкая проверка диапазона
                range_ok = True
                if 'reference_range' in res and res['reference_range']:
                    res_range = res['reference_range']
                    range_ok = (abs(res_range[0] - gt_range[0]) < 5) and \
                               (abs(res_range[1] - gt_range[1]) < 5)

                y_true.append(1)
                y_pred.append(1 if (value_ok and unit_ok and range_ok) else 0)
                break

        if not found:
            y_true.append(1)
            y_pred.append(0)

    if not y_true:
        return {'precision': 0, 'recall': 0, 'f1': 0, 'time': exec_time}

    precision = precision_score(y_true, y_pred, zero_division=0)
    recall = recall_score(y_true, y_pred, zero_division=0)
    f1 = f1_score(y_true, y_pred, zero_division=0)

    return {
        'precision': precision,
        'recall': recall,
        'f1': f1,
        'time': exec_time
    }

def run_benchmarks():
    methods = [
        ('Regex', extract_with_regex),
        ('Rules', extract_with_rules),
        ('Similarity', extract_with_similarity),
        ('Semantic', extract_with_semantic)
    ]

    benchmarks = []

    for name, func in methods:
        metrics = evaluate_method(func)
        benchmarks.append({
            'Method': name,
            'Precision': metrics['precision'],
            'Recall': metrics['recall'],
            'F1-score': metrics['f1'],
            'Time (ms)': round(metrics['time'] * 1000, 2)
        })

    return pd.DataFrame(benchmarks)

# Запуск бенчмарков
benchmark_df = run_benchmarks()
print(benchmark_df)

# Визуализация
def plot_results(df):
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

    df.plot(x='Method', y=['Precision', 'Recall', 'F1-score'],
            kind='bar', ax=ax1, title='Quality Metrics')
    ax1.set_ylim(0, 1)
    ax1.grid(True, linestyle='--', alpha=0.7)

    df.plot(x='Method', y='Time (ms)',
            kind='bar', color='orange', ax=ax2, title='Execution Time')
    ax2.grid(True, linestyle='--', alpha=0.7)

    plt.tight_layout()
    plt.show()

plot_results(benchmark_df)

print(json.dumps(extract_with_regex(TEST_TEXT), ensure_ascii=False, indent=2), end = "\n\n\n\n")
print(json.dumps(extract_with_rules(TEST_TEXT), ensure_ascii=False, indent=2), end = "\n\n\n\n")
print(json.dumps(extract_with_similarity(TEST_TEXT), ensure_ascii=False, indent=2), end = "\n\n\n\n")
print(json.dumps(extract_with_semantic(TEST_TEXT), ensure_ascii=False, indent=2), end = "\n\n\n\n")